# encoding: utf-8
#!/usr/bin/env ruby

# Sublime Text 2 Settings
# sublime: x_syntax Packages/Ruby/Ruby.tmLanguage
# sublime: translate_tabs_to_spaces true
# sublime: tab_size  2

require 'optparse'
require 'ostruct'
require 'commander/import'

begin
  require 'githooker'
rescue GitHooker::Repo::NotAGitRepoError
  puts "Please switch to a git repository directory."
  exit 1
end

program :name, 'Foo Bar'
program :version, '1.0.0'
program :description, 'Stupid command that prints foo or bar.'

GIT_HOOKS = %w(
  pre-commit prepare-commit-msg commit-msg post-commit
  applypatch-msg pre-applypatch post-applypatch
  pre-rebase post-merge
  update post-update
)

COMMANDS = %w(stub remove show edit run).collect(&:to_sym)

STUB_TEMPLATE = <<-EOF
#!/usr/bin/env ruby

require 'githooker'

GitHooker::Hook.register do
  section "General"
  perform ""
end

GitHooker::Runner.start

EOF

def usage(error_message = nil, quit = true)
  $stderr.puts "Error: #{error_message}" if error_message
  $stderr.puts "Usage: #{Pathname.new($0).basename} COMMAND"
  $stderr.puts "COMMANDS:"
  $stderr.puts "       assign action <hook>   - generates a basic stub for the given <hook>, "
  $stderr.puts "                       or all hooks if 'all' is specified"
  $stderr.puts "       list [hook] - removes the given <hook>, or all hooks if "
  $stderr.puts "                      'all' is specified"
  $stderr.puts "       run <hook>    - runs the given hook in unstaged mode (specify"
  $stderr.puts "                       --stage to use staged mode)"
  $stderr.puts
  exit 1 if quit
end
usage unless ARGV.size >= 2

# rubocop:disable all
staged  = !!ARGV.delete('--staged')
# rubocop:enable all

command = ARGV.shift.downcase.to_sym
usage("invalid command '#{command}'") unless COMMANDS.include? command

hooks   = (ARGV.shift.split(/,/) rescue [])
usage("no valid hook provided") if hooks.empty?
if !hooks.include?('all') && (hooks - GIT_HOOKS).size > 0
  usage("Unsupported hook types: #{(hooks - GIT_HOOKS).join(', ')}\nValid Hooks: #{GIT_HOOKS.join(', ')}\n\n")
end
hooks = GIT_HOOKS.dup if hooks.include? 'all'

case command
  when :stub then
    Dir.chdir GitHooker::REPO_ROOT
    hooks.each do |hook|
    end
  when :remove then
  when :show then
  when :edit then
  when :run then
end

